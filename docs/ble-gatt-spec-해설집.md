# BLE GATT 스펙 해설집 — 비전공자를 위한 완전 가이드

> **이 문서는 뭔가요?**
> `ble-gatt-spec.md`(기술 스펙 문서)를 **비전공자도 이해할 수 있게** 풀어쓴 해설집입니다.
> 기술 용어가 나올 때마다 "그러니까..." 로 쉽게 설명하고, 실제 헬스장 상황 예시를 들어줍니다.

---

## 목차

1. [왜 이 문서가 필요한가?](#1-왜-이-문서가-필요한가)
2. [BLE가 뭔가요?](#2-ble가-뭔가요)
3. [GATT가 뭔가요?](#3-gatt가-뭔가요)
4. [UUID — 채널 번호 시스템](#4-uuid--채널-번호-시스템)
5. [서비스 3개 — 대화 주제 묶음](#5-서비스-3개--대화-주제-묶음)
6. [채널 12개 — 실제로 뭘 주고받나?](#6-채널-12개--실제로-뭘-주고받나)
7. [세션 데이터 — 운동 성적표](#7-세션-데이터--운동-성적표)
8. [명령어 — 앱이 센서에게 시키는 것](#8-명령어--앱이-센서에게-시키는-것)
9. [상태 머신 — 센서의 현재 상태](#9-상태-머신--센서의-현재-상태)
10. [연결 설정 — 블루투스 튜닝](#10-연결-설정--블루투스-튜닝)
11. [보안 — 남의 센서에 연결 못하게](#11-보안--남의-센서에-연결-못하게)
12. [연결 흐름 — 연결/끊김/재연결](#12-연결-흐름--연결끊김재연결)
13. [OTA — 무선 업데이트](#13-ota--무선-업데이트)
14. [헬스장 환경 대응](#14-헬스장-환경-대응)
15. [코드 예제 — 개발자가 쓸 코드](#15-코드-예제--개발자가-쓸-코드)
16. [자주 묻는 질문 (FAQ)](#16-자주-묻는-질문-faq)

---

## 1. 왜 이 문서가 필요한가?

### 비유: 건축 설계도

집을 지을 때를 생각해보세요:

```
설계도 없이 집 짓기:
  전기 기사: "콘센트 여기에 넣을게요"
  배관 기사: "거기 이미 배관 지나가는데요?"
  인테리어:  "벽 위치가 달라졌는데 누가 말 안 해줬네요"
  → 서로 뜯어고치느라 시간 3배, 비용 3배

설계도 먼저 확정하고 짓기:
  전기 기사: (설계도 보고 작업)
  배관 기사: (설계도 보고 작업)
  인테리어:  (설계도 보고 작업)
  → 각자 동시에 일해도 안 부딪힘!
```

**`ble-gatt-spec.md`가 바로 이 "설계도"입니다.**

- **앱 개발자**: "아, 무게는 FCA00002 채널로 받으면 되는구나"
- **펌웨어 개발자**: "아, 무게는 FCA00002 채널로 보내면 되는구나"
- 둘이 만나서 이야기 안 해도 **각자 코딩하면 딱 맞음**

### 이 설계도가 없으면?

```
센서 개발자: 무게를 숫자 1000으로 보냄 (100.0kg이라는 뜻)
앱 개발자:   1000을 받고 "1000kg?!" 이라고 표시
→ 버그!

설계도에 "1000 = 100.0kg (10으로 나눠라)" 라고 쓰여있으면 → 이런 실수 불가능
```

---

## 2. BLE가 뭔가요?

### 한줄 설명

**BLE = Bluetooth Low Energy = 배터리 적게 먹는 블루투스**

### 일반 블루투스 vs BLE

```
일반 블루투스 (Classic):
  - 음악 스트리밍, 전화 통화용
  - 배터리 많이 먹음
  - 에어팟, 블루투스 스피커가 이걸 씀

BLE:
  - 작은 데이터 조금씩 보내는 용도
  - 배터리 엄청 적게 먹음 (코인 배터리로 몇 달)
  - 스마트 워치, 체중계, 심박수 밴드가 이걸 씀
  - Fica도 이걸 씀! ←
```

### 왜 BLE를 선택했나?

```
운동할 때 보내는 데이터:
  "3회" (숫자 하나)
  "4회" (숫자 하나)
  "5회" (숫자 하나)
  ...

이렇게 작은 숫자 하나씩만 보내면 되니까
→ 일반 블루투스(음악용)는 과하고
→ BLE(소량 데이터용)가 딱 맞음
→ 게다가 배터리도 오래 감!
```

### Fica에서 BLE의 역할

```
┌──────────┐          ┌──────────┐
│          │   BLE    │          │
│ Fica     │ ◄──────► │ V2log    │
│ 센서     │  (무선)   │ 앱       │
│          │          │          │
│ "5회!"   │ ───────► │ 화면에   │
│          │          │ "5회"    │
│          │          │ 표시     │
└──────────┘          └──────────┘
  기구에 부착             폰에 설치
```

---

## 3. GATT가 뭔가요?

### 한줄 설명

**GATT = 블루투스로 데이터를 주고받는 규칙 = "대화 규칙"**

### 비유: 우체국 시스템

GATT를 우체국에 비유하면 이해하기 쉬워요:

```
우체국 시스템:
  우체국 = "서비스(Service)"
  사서함 = "캐릭터리스틱(Characteristic)"

  예) "피트니스 우체국" 안에 사서함이 12개 있음:
    1번 사서함: 횟수 알림용
    2번 사서함: 무게 알림용
    3번 사서함: 상태 알림용
    ...

  사서함마다 규칙이 다름:
    1번: "읽기만 가능" (센서가 넣고, 앱이 꺼내봄)
    2번: "읽기+쓰기 가능" (앱이 넣을 수도 있고, 센서가 넣을 수도 있음)
```

### GATT 용어를 우체국으로 대응

| 기술 용어 | 우체국 비유 | 예시 |
|-----------|-----------|------|
| **Service** (서비스) | 우체국 건물 | "피트니스 우체국", "배터리 우체국" |
| **Characteristic** (캐릭터리스틱) | 사서함 | "횟수 사서함", "무게 사서함" |
| **Read** (읽기) | 사서함 열어서 확인 | 앱이 현재 무게를 읽어봄 |
| **Write** (쓰기) | 사서함에 편지 넣기 | 앱이 "무게 100kg으로 설정해" 라고 넣음 |
| **Notify** (알림) | "편지 왔어요!" 자동 알림 | 횟수 바뀔 때마다 센서가 자동으로 알려줌 |
| **Indicate** (확인 알림) | 등기 우편 (수신 확인 필수) | 세션 데이터는 확실히 받았는지 확인 |
| **UUID** | 사서함 번호 | FCA00001 = 횟수 사서함 |

### Notify vs Indicate — 뭐가 다른가?

```
Notify (일반 알림):
  센서: "지금 3회야!" → 앱한테 보냄
  앱:   (받든 못 받든, 센서는 신경 안 씀)
  → 빠름! 하지만 가끔 빠질 수 있음
  → 횟수, 타이머처럼 자주 바뀌는 것에 적합

Indicate (확인 알림):
  센서: "운동 끝! 성적표 보낼게" → 앱한테 보냄
  앱:   "받았어!" → 센서에게 확인
  센서: "확인 받았으니 OK"
  → 느리지만 확실함!
  → 세션 데이터(운동 성적표)처럼 절대 빠지면 안 되는 것에 적합
```

### Server와 Client — 누가 뭔가?

```
GATT Server = 데이터를 가지고 있는 쪽 = Fica 센서
  "나한테 횟수 데이터 있어. 필요하면 가져가"

GATT Client = 데이터를 요청하는 쪽 = V2log 앱
  "횟수 데이터 줘!" / "무게 100kg으로 바꿔줘!"

비유:
  식당(Server) = 센서 (메뉴=데이터를 가지고 있음)
  손님(Client) = 앱 (주문=요청을 하는 쪽)
```

---

## 4. UUID — 채널 번호 시스템

### 한줄 설명

**UUID = 사서함 고유 번호 = TV 채널 번호 같은 것**

### TV 채널에 비유

```
TV:
  KBS1  = 채널 9번
  MBC   = 채널 11번
  SBS   = 채널 6번
  → 번호만 알면 원하는 방송을 찾을 수 있음

Fica BLE:
  횟수    = 채널 FCA00001
  무게    = 채널 FCA00002
  상태    = 채널 FCA00003
  → 번호만 알면 원하는 데이터를 찾을 수 있음
```

### 왜 이렇게 긴 번호를 쓰나?

```
짧은 번호 (16비트): 0x180F, 0x2A19
  → 블루투스 공식 기관(SIG)이 미리 정해놓은 번호
  → 배터리(0x180F), 심박수(0x180D) 등 전세계 공통
  → Fica만의 고유 기능에는 못 씀 (이미 다 차지됨)

긴 번호 (128비트): FCA00001-0001-4000-8000-00805F9B34FB
  → 우리(Fica)가 직접 만든 번호
  → 전세계에서 이 번호는 Fica만 씀 (겹칠 확률 0%)
  → 12개 채널에 우리 마음대로 의미 부여
```

### 전체 채널 목록

```
Fica 전용 채널 12개:

  FCA00001 = 횟수 (Rep Count)        — "지금 몇 회째야?"
  FCA00002 = 무게 (Weight)           — "지금 몇 kg이야?"
  FCA00003 = 상태 (Set Status)       — "운동 중? 쉬는 중? 끝?"
  FCA00004 = 현재 세트 (Current Set) — "지금 몇 세트째야?"
  FCA00005 = 총 세트 (Total Sets)    — "오늘 총 몇 세트 할 거야?"
  FCA00006 = 휴식 타이머 (Rest Timer)— "남은 휴식 시간 몇 초?"
  FCA00007 = 휴식 시간 (Rest Duration)— "세트 간 몇 초 쉴 거야?"
  FCA00008 = 세션 데이터              — "운동 끝! 전체 성적표"
  FCA00009 = 기구 ID (Equipment ID)  — "이 기구는 벤치프레스 3번"
  FCA0000A = 명령 (Command)          — "시작해!" "멈춰!"
  FCA0000B = IMU 상태 (센서 상태)    — "가속도 센서 정상이야?"
  FCA0000C = 에러 코드               — "배터리 부족!" "센서 이상!"

블루투스 공식 채널 2개:
  0x180F   = 배터리 서비스           — "배터리 85% 남음"
  0x180A   = 기기 정보 서비스        — "제조사: Fica, 모델: FC-001"
```

---

## 5. 서비스 3개 — 대화 주제 묶음

### 비유: 학교의 교무실

```
학교에 교무실이 3개 있다고 생각하면:

1. "체육 교무실" (Fica Fitness Service)
   → 운동 관련 모든 것: 횟수, 무게, 세트, 타이머...
   → 사서함 12개

2. "행정 교무실" (Battery Service)
   → 배터리 관련
   → 사서함 1개 (배터리 잔량)

3. "교장실" (Device Information Service)
   → 기기 기본 정보
   → 사서함 4개 (제조사, 모델명, 펌웨어 버전, 하드웨어 버전)
```

### 왜 굳이 나누나?

```
다 합치면 안 되나? → 안 되는 건 아닌데, 나누는 게 좋음

이유 1: 표준 호환
  배터리 서비스(0x180F)는 전세계 BLE 기기가 다 쓰는 표준
  → 아이폰이 "이 기기 배터리 몇 %야?" 자동으로 물어볼 수 있음
  → 우리가 따로 코딩 안 해도 OS가 알아서 처리

이유 2: 정리
  체육 관련 12개 사서함은 "체육 교무실"에 다 모여있으니
  → 앱이 "체육 교무실(FCA00000) 보여줘" 하면 12개가 한꺼번에 나옴
  → 하나하나 따로 찾을 필요 없음
```

---

## 6. 채널 12개 — 실제로 뭘 주고받나?

### 실제 운동 시나리오로 따라가기

관주님이 헬스장에서 벤치프레스 100kg × 10회 × 4세트를 한다고 해봅시다:

#### 준비 단계

```
상황: 벤치프레스 기구에 앉아서, 폰으로 기구 NFC를 탭!

▶ Equipment ID (FCA00009)
  방향: 센서 → 앱
  내용: "550e8400-e29b-41d4..." (벤치프레스 3번 ID)

  그러니까: "이 기구는 벤치프레스 3번이에요" 라고 앱에 알려줌
  → 앱이 "아, 벤치프레스구나! 지난번에 100kg 했었네" 자동 표시

▶ Set Status (FCA00003)
  방향: 센서 → 앱
  내용: 0x01 (READY)

  그러니까: "준비됐어요! 운동 시작해도 돼요" 신호

▶ Weight (FCA00002)
  방향: 앱 → 센서
  내용: 1000 (= 100.0kg)

  그러니까: 앱이 "오늘 100kg으로 할게" 라고 센서에 알려줌
  → 센서의 7-세그먼트 LED에 "100.0" 표시

  왜 1000이지 100이 아닌가?
  → 소수점을 쓸 수 없어서 10배로 보냄
  → 100.0kg × 10 = 1000
  → 2.5kg × 10 = 25
  → 받는 쪽에서 10으로 나누면 원래 무게가 됨

▶ Total Sets (FCA00005)
  방향: 앱 → 센서
  내용: 4

  그러니까: "오늘 4세트 할 거야" → LED 10개 중 4개 켜짐

▶ Rest Duration (FCA00007)
  방향: 앱 → 센서
  내용: 90 (= 90초)

  그러니까: "세트 사이에 90초 쉴 거야"
```

#### 1세트 운동 중

```
상황: 바벨을 들어올리기 시작!

▶ Set Status (FCA00003)
  방향: 센서 → 앱
  내용: 0x02 (EXERCISING)

  그러니까: "운동 시작됐어요!" (IMU 센서가 움직임 감지)

▶ Rep Count (FCA00001) — 계속 올라감!
  방향: 센서 → 앱

  (1번째 들어올림) → 1 보냄 → 앱 화면: "1"
  (2번째 들어올림) → 2 보냄 → 앱 화면: "2"
  (3번째 들어올림) → 3 보냄 → 앱 화면: "3"
  ...
  (10번째 들어올림) → 10 보냄 → 앱 화면: "10"

  그러니까: 바벨을 들어올릴 때마다 자동으로 숫자가 올라감
  → 앱 화면에 실시간으로 표시됨
  → 사용자가 직접 세지 않아도 됨!
```

#### 1세트 끝 → 휴식

```
상황: 바벨을 내려놓고 2~3초 동안 안 움직임

▶ Set Status (FCA00003)
  방향: 센서 → 앱
  내용: 0x03 (RESTING)

  그러니까: "세트 끝난 것 같아요! 쉬세요" (2~3초 무동작 감지)

▶ Current Set (FCA00004)
  방향: 센서 → 앱
  내용: 2

  그러니까: "1세트 끝! 다음은 2세트" → LED 1번 완료 색으로 변경

▶ Rest Timer (FCA00006) — 매초마다 카운트다운!
  방향: 센서 → 앱

  90 보냄 → 앱: "1:30"
  89 보냄 → 앱: "1:29"
  88 보냄 → 앱: "1:28"
  ...
  1 보냄 → 앱: "0:01"
  0 보냄 → 앱: "시간 끝!" → 진동/알림

  그러니까: 자동으로 90초 카운트다운
  → 시간 되면 "다시 운동하세요!" 알림
```

#### 2~4세트 반복

```
(위 과정 반복 × 3번 더)

2세트: 100kg × 8회 → 휴식 90초
3세트: 무게 변경! 센서에서 -버튼 → Weight Notify: 900 (90.0kg)
       90kg × 10회 → 휴식 90초
4세트: 90kg × 8회 → 마지막 세트!
```

#### 운동 완료!

```
상황: 4세트 다 끝남!

▶ Set Status (FCA00003)
  방향: 센서 → 앱
  내용: 0x04 (COMPLETE)

  그러니까: "전체 운동 완료!"

▶ Session Data (FCA00008) — 성적표 전송!
  방향: 센서 → 앱 (Indicate = 확실히 전달)
  내용: (아래 §7에서 자세히 설명)

  그러니까: "오늘 성적표"를 한꺼번에 보냄:
  → 1세트: 100kg, 10회, 휴식 90초, 소요 30초
  → 2세트: 100kg, 8회, 휴식 90초, 소요 35초
  → 3세트: 90kg, 10회, 휴식 90초, 소요 32초
  → 4세트: 90kg, 8회, 소요 37초
```

### 채널별 방향 정리

```
센서 → 앱 (센서가 보내고, 앱이 받는 것):
  "횟수 3이야" (Rep Count)
  "운동 중이야" (Set Status)
  "지금 2세트야" (Current Set)
  "남은 휴식 89초" (Rest Timer)
  "성적표야" (Session Data)
  "가속도계 정상이야" (IMU Status)
  "에러났어!" (Error Code)

앱 → 센서 (앱이 보내고, 센서가 받는 것):
  "무게 100kg으로 해" (Weight)
  "4세트 할 거야" (Total Sets)
  "90초 쉴게" (Rest Duration)
  "세션 시작해!" (Command)

양방향:
  무게 (Weight) — 앱에서도 설정, 센서 버튼으로도 변경 가능
```

---

## 7. 세션 데이터 — 운동 성적표

### 한줄 설명

**운동 끝나면 "오늘 뭘 얼마나 했는지" 성적표를 한꺼번에 보내는 것**

### 성적표 구조

```
실제 운동 결과:
  1세트: 100kg, 10회, 휴식 90초, 소요 30초
  2세트: 100kg, 8회, 휴식 90초, 소요 35초
  3세트: 90kg, 10회, 휴식 90초, 소요 32초
  4세트: 90kg, 8회, 휴식 0초, 소요 37초

이걸 센서가 이렇게 포장해서 보냄:

  ┌─── 봉투(헤더) ───┐  ┌─── 1세트 ──────────┐
  │ 세션번호 │ 4세트  │  │ 100kg │10회│90초│30초│
  └─────────┴────────┘  └───────┴────┴────┴────┘

  ┌─── 2세트 ──────────┐  ┌─── 3세트 ──────────┐
  │ 100kg │8회 │90초│35초│  │ 90kg │10회│90초│32초│
  └───────┴────┴────┴────┘  └──────┴────┴────┴────┘

  ┌─── 4세트 ──────────┐
  │ 90kg │8회 │0초 │37초│
  └──────┴────┴────┴────┘
```

### 왜 이렇게 포장하나?

```
보내는 방법 A: 하나씩 따로 보내기 ← 비효율
  "1세트 무게: 100kg"
  "1세트 횟수: 10회"
  "1세트 휴식: 90초"
  ...
  → 전송 16번 필요 (4세트 × 4개 정보)
  → 중간에 블루투스 끊기면? 절반만 도착 → 망함

보내는 방법 B: 한꺼번에 묶어서 보내기 ← Fica가 쓰는 방식
  "여기 4세트 성적표 통째로!" (27바이트 1번 전송)
  → 전송 1번으로 끝
  → Indicate(확인 알림)로 보내니까 확실히 도착
```

### 27바이트가 뭔가?

```
컴퓨터는 모든 데이터를 "바이트"라는 단위로 저장/전송해요.

1바이트 = 숫자 0~255를 저장할 수 있는 칸 1개

4세트 성적표를 보내려면:
  봉투(헤더): 3칸 (세션번호 2칸 + 세트 수 1칸)
  세트 1개당: 6칸 (무게 2칸 + 횟수 1칸 + 휴식 1칸 + 소요시간 2칸)

  총: 3 + (4 × 6) = 27칸 = 27바이트

최대 10세트면:
  3 + (10 × 6) = 63바이트

iOS 폰이 한 번에 받을 수 있는 최대: 185바이트
63 < 185 → 쪼개지 않고 한 번에 보낼 수 있음!
```

### 무게를 왜 10배로 보내나?

```
문제: 소수점을 보내기 어려움
  바이트에는 정수(1, 2, 3...)만 저장 가능
  100.0kg, 2.5kg 같은 소수점 숫자는 직접 못 보냄

해결: 10배로 곱해서 보내기
  100.0kg → 1000 으로 보냄 (받는 쪽에서 ÷10)
  2.5kg   → 25 로 보냄   (받는 쪽에서 ÷10)
  90.0kg  → 900 으로 보냄 (받는 쪽에서 ÷10)

왜 2칸(2바이트) 쓰나?
  1칸 = 최대 255
  → 25.5kg까지밖에 표현 못함 → 부족!
  2칸 = 최대 65,535
  → 6,553.5kg까지 표현 가능 → 충분!
  → 실제론 0~500.0kg(=0~5000)만 씀
```

### Little-Endian이 뭔가?

```
숫자 1000을 2칸에 넣을 때:

  Big-Endian (큰 자릿수 먼저):
    [03] [E8]  ← 사람이 읽기 편함 (0x03E8 = 1000)

  Little-Endian (작은 자릿수 먼저):
    [E8] [03]  ← 컴퓨터가 처리하기 편함

  Fica는 Little-Endian을 씀!
  → 그냥 "숫자 넣는 순서 규칙"이라고 생각하면 됨
  → 코드에서 자동 처리되니까 관주님이 신경 쓸 건 없음
```

---

## 8. 명령어 — 앱이 센서에게 시키는 것

### 한줄 설명

**앱에서 센서에게 "이거 해!" 하는 리모컨 버튼들**

### 리모컨에 비유

```
TV 리모컨:
  전원 버튼 = TV 켜기/끄기
  채널 ▲  = 채널 올리기
  볼륨 ▲  = 소리 키우기

Fica 리모컨 (앱 → 센서):
  0x01 = "세션 시작해!" (START_SESSION)
  0x02 = "세션 끝내!" (STOP_SESSION)
  0x04 = "휴식 스킵!" (SKIP_REST)
  0x10 = "업데이트 시작해!" (OTA_START)
  0xFF = "공장 초기화해!" (FACTORY_RESET)
```

### 전체 리모컨 버튼 목록

```
운동 관련 버튼 (자주 쓸 것들):
  0x01 START_SESSION  = "운동 시작!"
  0x02 STOP_SESSION   = "운동 끝!" (중간에 그만둘 때)
  0x03 RESET_SET      = "이 세트 다시!" (횟수 0으로)
  0x04 SKIP_REST      = "휴식 건너뛰기!" (바로 다음 세트)
  0x05 ADD_SET        = "세트 하나 추가!"
  0x06 REMOVE_SET     = "세트 하나 빼기!"
  0x08 PAUSE_SESSION  = "잠깐 멈춰!" (화장실 갈 때)
  0x09 RESUME_SESSION = "다시 시작!"

시스템 버튼 (관리용):
  0x10 OTA_START      = "새 소프트웨어 설치 시작"
  0x11 OTA_ABORT      = "설치 취소"
  0xFE PING           = "살아있어?" (연결 확인용)
  0xFF FACTORY_RESET  = "완전 초기화" (위험! 확인 코드 필요)
```

### 안전 장치: FACTORY_RESET

```
FACTORY_RESET(0xFF)은 모든 데이터가 날아가는 위험한 명령!

그래서 안전 장치가 있음:
  앱이 0xFF만 보내면? → 무시됨!
  앱이 0xFF + 0xAA를 보내면? → "정말로 초기화하겠다는 거구나" → 실행

비유: 핵 미사일 발사 버튼처럼 두 사람이 동시에 키를 돌려야 하는 것
→ 실수로 눌러서 데이터 날아가는 사고 방지
```

---

## 9. 상태 머신 — 센서의 현재 상태

### 한줄 설명

**"센서가 지금 뭐 하고 있는지" 를 나타내는 것. 신호등처럼 상태가 바뀜.**

### 신호등에 비유

```
교통 신호등:
  빨간불 → 노란불 → 초록불 → 빨간불 → ...
  각 상태에서 할 수 있는 행동이 정해져 있음

Fica 상태등:
  IDLE → READY → EXERCISING → RESTING → EXERCISING → ... → COMPLETE → IDLE

  각 상태에서 센서가 하는 일이 다름:
    IDLE:       아무것도 안 함, 전력 절약
    READY:      LED 켜짐, 운동 시작 대기
    EXERCISING: 횟수 세는 중!
    RESTING:    타이머 카운트다운 중
    COMPLETE:   성적표 전송 중
```

### 관주님의 STEP 0~6이랑 1:1 대응

```
STEP 0: 기구에 가까이 감        → IDLE (대기)
        "센서 켜져있고, NFC 탭 기다리는 중"

STEP 1: 폰으로 NFC 탭!          → IDLE → READY
        "기구 인식됨! LED에 무게/세트 표시"

STEP 2: 앱에서 세트 수 설정      → READY 유지
        "4세트 할 거야, 100kg으로"

STEP 3: 바벨 들어올림!           → READY → EXERCISING
        "운동 시작! 1...2...3...10!" 자동 카운팅

STEP 4: 바벨 내려놓음 (3초 무동작) → EXERCISING → RESTING
        "1세트 끝! 휴식 타이머: 90...89...88..."

STEP 5: 2~4세트 반복             → EXERCISING ↔ RESTING 반복
        "다음 세트! 또 카운팅..."

STEP 6: 마지막 세트 끝!          → RESTING → COMPLETE → IDLE
        "전체 완료! 성적표 전송, 10초 후 대기로 복귀"
```

### 상태 전이 다이어그램 (쉬운 버전)

```
    [IDLE] ──NFC 탭──→ [READY] ──움직임!──→ [EXERCISING]
      ↑                                         │
      │                                    3초 멈춤
      │                                         │
      │                                         ▼
      │                                    [RESTING]
      │                                    │       │
      │                              세트 남음  마지막 세트
      │                                    │       │
      │                                    ▼       ▼
      │                              [EXERCISING] [COMPLETE]
      │                                              │
      └──────────── 10초 후 ─────────────────────────┘

    [ERROR] ← 어디서든 에러 나면 여기로 → 복구되면 [IDLE]로
```

### "왜 굳이 상태를 만드나?"

```
상태가 없으면:
  센서: (횟수를 보냄) "3"
  앱:   "이게 운동 중이라는 거야? 아니면 쉬는 중에 잘못 세진 거야?"
  → 구분 불가능!

상태가 있으면:
  센서: "EXERCISING" + "3"
  앱:   "운동 중이고, 3회째구나!" → 정확한 화면 표시 가능

비유:
  "3" 만 말하면 → 점수 3점? 시간 3분? 사람 3명?
  "운동 중 3회째" 라고 하면 → 명확!
```

---

## 10. 연결 설정 — 블루투스 튜닝

### 비유: 전화 통화 품질 설정

```
전화할 때:
  시끄러운 곳 → 볼륨 높이고, 자주 "잘 들려?" 확인
  조용한 곳 → 볼륨 낮추고, 확인 덜 함

Fica BLE도 비슷:
  운동 중 → 자주 통신 (50ms마다 = 0.05초마다)
         → 횟수가 실시간으로 올라가야 하니까!
  쉬는 중 → 가끔 통신 (500ms마다 = 0.5초마다)
         → 타이머만 보면 되니까, 배터리 아끼자
  대기 중 → 아주 가끔 (1000ms마다 = 1초마다)
         → 연결만 유지하면 됨
```

### 광고(Advertising)가 뭔가?

```
광고 = "나 여기 있어!" 하는 무선 외침

비유: 택시 기사가 빈차 표시등을 켜고 다니는 것
  승객(앱)이 빈차 표시(광고)를 보고 택시(센서)를 찾음

  센서 전원 ON → "Fica-A3F2" 이름으로 광고 시작
  → 처음 30초: 0.1초마다 외침 (빨리 찾아달라고)
  → 30초 후:  1초마다 외침 (배터리 절약)

  앱에서 "Fica-" 로 시작하는 기기 검색 → 발견! → 연결
```

### MTU가 뭔가?

```
MTU = 한 번에 보낼 수 있는 데이터 최대 크기

비유: 택배 상자 크기
  작은 상자 (23바이트) → 한 번에 조금만 넣을 수 있음
  큰 상자 (247바이트) → 한 번에 많이 넣을 수 있음

  운동 성적표(63바이트)를 보내려면:
    작은 상자 → 여러 번에 나눠 보내야 함 (번거로움)
    큰 상자 → 한 번에 들어감! (간편)

  Fica는 "큰 상자 주세요" (247바이트 요청)
  → Android: "네, 247바이트요" (OK!)
  → iOS: "아이폰은 185바이트까지만 돼요" (좀 작지만 63바이트는 충분!)
```

---

## 11. 보안 — 남의 센서에 연결 못하게

### 현재: Just Works (Phase 1)

```
비유: 아파트 자동문
  거주자가 가까이 가면 자동으로 열림
  비밀번호 안 누르지만, 문 자체는 잠겨있음

Just Works:
  앱이 센서에 연결 요청 → 자동 연결됨 (비밀번호 없음)
  하지만! 연결 후 데이터는 AES-128로 암호화됨
  → 중간에 누가 엿듣기 어려움

왜 비밀번호 안 쓰나?
  → 센서에 키패드가 없음 (버튼 3개뿐)
  → 헬스장에서 매번 비밀번호 치면 UX 최악
  → 운동 데이터는 의료 데이터가 아니라서 이 정도면 충분
```

### 미래: Numeric Comparison (Phase 2, B2B)

```
비유: 호텔 키카드
  프론트에서 카드 받아야 방 열림
  다른 투숙객 카드로는 내 방 못 열음

Numeric Comparison:
  센서 LED: "4278"
  앱 화면:  "4278 맞나요?"
  사용자:   "맞아!" → 연결 허용

  → 옆 사람이 가짜 센서를 만들어도 숫자가 다르게 나옴
  → 헬스장 납품(B2B)할 때 보안 강화용
  → 지금은 안 만들고, 나중에 필요할 때 추가 (펌웨어 업데이트로 가능)
```

### 본딩(Bonding)이 뭔가?

```
비유: 즐겨찾기
  한 번 연결한 폰을 "기억"해둠
  다음에 자동으로 연결 (매번 페어링 안 해도 됨)

  처음 연결: "이 폰 기억해둘게" (본딩)
  다음 방문: 센서가 "아, 아까 그 폰이네!" → 자동 연결

  최대 8대 폰까지 기억 가능
  → 헬스장에서 회원 8명이 같은 기구 사용 가능
```

---

## 12. 연결 흐름 — 연결/끊김/재연결

### 최초 연결 (7단계, 약 0.6초)

```
일상 비유로 설명하면:

1. 스캔 (0.1초)
   → 앱: "Fica- 로 시작하는 기기 있나?" 찾기
   → 비유: 주차장에서 내 차 찾기 (깜빡이 누르기)

2. 연결 (0.05초)
   → 앱-센서 손잡기
   → 비유: 전화 연결 "여보세요?"

3. MTU 협상 (0.05초)
   → "데이터 얼마나 큰 덩어리로 보낼까?"
   → 비유: "택배 상자 크기 정하기"

4. PHY 업그레이드 (0.05초)
   → "속도 더 빨리 할 수 있으면 빠르게 하자"
   → 비유: "일반도로에서 고속도로로 올라가기"

5. 서비스 탐색 (0.2초)
   → "어떤 채널들이 있는지 목록 달라"
   → 비유: "식당 메뉴판 받기"

6. 알림 구독 (0.1초)
   → "횟수 바뀌면 자동으로 알려줘"
   → 비유: "유튜브 채널 구독 (알림 설정)"

7. 초기값 설정 (0.05초)
   → "무게 100kg, 4세트, 휴식 90초로 해줘"
   → 비유: "주문하기"

총 약 0.6초! 사용자가 NFC 탭 하면 거의 즉시 연결됨
```

### 연결 끊겼을 때 (재연결)

```
헬스장에서 블루투스 끊기는 경우:
  - 폰이 너무 멀어짐 (기구 위에 놔두고 물 마시러 감)
  - 다른 블루투스 기기 간섭
  - 폰 배터리 절전 모드

끊기면 어떻게 되나?

센서 쪽:
  "어? 연결 끊겼네. 그래도 운동은 계속 세자"
  → 횟수 계속 카운팅!
  → 결과를 내부 메모리에 저장

앱 쪽:
  3초마다 재연결 시도 (최대 10번 = 30초)

  [0초] 시도 #1 → 실패
  [3초] 시도 #2 → 실패
  [6초] 시도 #3 → 성공!
  → 센서: "그동안 쌓인 데이터 보내줄게!"
  → 앱에 밀린 횟수/세트 한꺼번에 도착

30초 안에 재연결 실패하면?
  → 앱: "센서 연결 끊김" 메시지 표시
  → 센서: 데이터를 저장해두고, 다음 연결 때 전송
  → 데이터는 절대 사라지지 않음!
```

### 3중 안전망 — 데이터 절대 안 사라짐

```
걱정: "블루투스 끊기면 운동 기록이 날아가나?"
답변: "절대 안 날아갑니다!" — 3중 안전망이 있으니까요

1층 방어: 센서 내부 메모리
  → 끊겨도 센서가 계속 기록
  → 재연결 시 앱으로 전송

2층 방어: 앱 로컬 저장소 (Hive)
  → 앱이 받은 데이터를 폰에 저장
  → 인터넷 없어도 폰에 남아있음

3층 방어: Supabase 클라우드
  → 인터넷 되면 서버에 업로드
  → 폰을 바꿔도 기록 유지

비유:
  은행 돈을 3군데에 나눠 넣은 것
  → 지갑(센서) 잃어버려도 통장(앱)에 있고
  → 통장(앱) 잃어버려도 은행(서버)에 있음
```

---

## 13. OTA — 무선 업데이트

### 한줄 설명

**USB 꽂지 않고, 블루투스로 센서 소프트웨어를 업데이트하는 것**

### 비유: 스마트폰 업데이트

```
아이폰 업데이트:
  설정 → 소프트웨어 업데이트 → 다운로드 → 설치 → 재시작

Fica 센서 업데이트 (OTA):
  V2log 앱 → "새 펌웨어 있음" → 전송 시작 → 설치 → 재부팅
  → USB 케이블 없이 블루투스로!
  → 헬스장에 설치된 센서도 원격 업데이트 가능!
```

### 안전 장치

```
걱정: "업데이트 중에 블루투스 끊기면?"

안전 장치 4개:

1. 이중 저장 (Dual-Bank)
   비유: 파일 수정 전에 원본 복사해두기
   → 새 버전에 문제 있으면 이전 버전으로 자동 복귀

2. 배터리 체크
   → 배터리 30% 미만이면 업데이트 거부
   → "충전 먼저 하세요!" 메시지

3. 서명 확인
   → 우리(Fica)가 만든 소프트웨어인지 확인
   → 해커가 만든 가짜 소프트웨어는 설치 불가

4. 자동 복구 타이머
   → 업데이트 시작 후 60초 안에 데이터 안 오면? 자동 재부팅
   → 센서가 멈춘 채로 방치되는 일 없음

시간: 약 13초면 업데이트 완료 (256KB 기준)
```

---

## 14. 헬스장 환경 대응

### 헬스장이 BLE한테 왜 힘든 환경인가?

```
헬스장에 있는 무선 기기들:
  - Wi-Fi 공유기 (2.4GHz)
  - 블루투스 이어폰 20개 (회원들 에어팟)
  - 블루투스 심박수 밴드 10개
  - 스마트 체중계
  - 트레드밀 내장 블루투스
  ...

이게 전부 같은 2.4GHz 주파수를 공유!
→ 채널이 겹치면 신호가 깨짐 (라디오 잡음 같은 것)
```

### 해결: AFH (자동 주파수 호핑)

```
비유: 라디오 주파수 자동 변경

  "이 채널 잡음 심하네?" → "다른 채널로 바꾸자!"
  → BLE가 알아서 깨끗한 채널을 찾아 이동
  → 우리가 코드를 짤 필요 없음! 자동으로 됨!

실제로:
  BLE 채널 37개 중, Wi-Fi가 쓰는 채널 ~15개를 피하고
  나머지 ~22개 채널에서 통신
  → 간섭 없음!
```

### 옆 기구 센서랑 섞이지 않나?

```
걱정: "벤치프레스 센서 데이터가 옆 스쿼트랙 센서로 가면?"

답: 절대 안 섞임!

  [벤치프레스 Fica-A3F2] ↔ [회원1 폰]  ← 이 둘만 통신
  [스쿼트랙  Fica-B7C1] ↔ [회원2 폰]  ← 이 둘만 통신

  각 쌍이 완전히 독립적
  → 1:1 연결이라서 다른 폰이 끼어들 수 없음
  → 암호화도 되어있어서 엿들을 수도 없음

기구 100대가 있어도?
  → 각 센서-폰 쌍이 독립적이라 100개든 1000개든 상관없음
```

---

## 15. 코드 예제 — 개발자가 쓸 코드

### 이건 왜 있나?

```
앱 개발자와 펌웨어 개발자가 "복사+붙여넣기" 할 수 있는 예제 코드

예시:
  앱 개발자: "세션 데이터를 어떻게 읽지?"
  → §13.4 복붙 → 바로 동작!

  펌웨어 개발자: "세션 데이터를 어떻게 만들지?"
  → §13.2 복붙 → 바로 동작!

관주님이 직접 코딩할 부분은 아니에요.
개발자들이 참고하는 "코드 레시피"입니다.
```

---

## 16. 자주 묻는 질문 (FAQ)

### Q: 이 문서를 내가 외워야 하나?

```
A: 아니요! 이 문서는 "사전" 같은 겁니다.
   필요할 때 찾아보는 것이지, 외우는 게 아닙니다.

   관주님이 알아야 할 것:
   - "이런 문서가 있다" (설계도가 완성됐다는 사실)
   - 큰 그림 (센서↔앱이 12개 채널로 통신한다)
   - STEP 0~6이 어떻게 구현되는지 (이 해설집의 §9)

   나머지는 개발자들이 참고합니다.
```

### Q: 이 문서가 완성됐으면, 다음 할 일은?

```
A: 이 순서로 진행됩니다:

  1. ✅ BLE 프로토콜 설계 (이 문서) — 완료!
  2. ⬜ 앱 BLE 연동 코드 — Flutter에서 이 약속대로 코딩
  3. ⬜ 펌웨어 개발 — 임베디드 개발자가 센서에서 이 약속대로 코딩
  4. ⬜ 하드웨어 제작 — PCB 설계 + 케이스
  5. ⬜ 프로토타입 테스트 — 헬스장에서 실제 테스트

  2번과 3번은 이 문서 덕분에 동시에 할 수 있어요!
```

### Q: 임베디드 개발자한테 이 문서를 주면 되나?

```
A: 네! 정확히 그 용도입니다.

  관주님 → 임베디드 개발자에게:
  "이 문서(ble-gatt-spec.md)대로 센서 펌웨어 만들어주세요.
   앱에서는 이미 이 약속대로 코딩하고 있으니까요."

  개발자가 이 문서를 보면:
  - "아, FCA00001로 횟수 Notify 보내면 되는구나"
  - "무게는 10배로 곱해서 보내야 하는구나"
  - "상태는 IDLE→READY→EXERCISING→RESTING→COMPLETE 순이구나"
  → 바로 코딩 가능!
```

### Q: 관주님이 결정해야 할 것은?

```
현재 미결정 사항 3개:

1. 총 세트 수를 어디서 입력하나?
   옵션 A: 앱에서만 입력 → 센서에 전송
   옵션 B: 센서 버튼으로도 입력 가능
   → 현재 문서는 "앱에서 Write" 방식으로 작성

2. 횟수를 실시간으로 보낼까, 세트 끝나고 보낼까?
   옵션 A: 실시간 (1회마다 BLE 전송) → 앱 화면에 즉시 표시
   옵션 B: 세트 끝나고 한꺼번에 → 배터리 절약
   → 현재 문서는 "실시간 Notify" 방식으로 작성

3. 센서 모델 (ICM-45686 vs LSM6DSV)
   → BLE 프로토콜에는 영향 없음 (어떤 센서든 같은 규약 사용)
```

### Q: 나중에 변경할 수 있나?

```
A: 네! 이 문서는 v1.0이고, 필요하면 v1.1, v2.0으로 업데이트합니다.

  예를 들어:
  - "채널 하나 더 필요해" → FCA0000D 추가
  - "무게 최대를 999kg까지 올리고 싶어" → 범위 수정
  - "B2B 기능 추가" → 새 Command 코드 추가

  다만 한 번 센서를 양산하면 큰 변경은 어려우니까,
  가능한 한 v1.0에서 잘 잡아두는 게 중요합니다.
```

### Q: "Little-Endian"이 중요한 건가? 내가 신경 써야 하나?

```
A: 관주님이 신경 쓸 필요 없습니다!

  그냥 "숫자를 저장하는 순서 규칙" 인데,
  코드에서 자동으로 처리됩니다.

  개발자들이 알아야 하는 건:
  "100.0kg을 보낼 때 [E8, 03]으로 보내야지 [03, E8]로 보내면 안 됨"
  → 이걸 이 문서에 명확히 적어놨으니 실수할 일 없음
```

---

> **이 해설집 요약**: `ble-gatt-spec.md`는 센서와 앱의 "대화 약속서"입니다.
> 12개 채널(UUID)로 횟수/무게/상태/타이머/성적표를 주고받고,
> 관주님의 STEP 0~6이 자동으로 돌아가게 하는 기술 설계도예요.
> 이 문서가 있으면 앱 개발자와 펌웨어 개발자가 동시에 독립적으로 일할 수 있습니다.
